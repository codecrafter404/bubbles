package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"fmt"
	"log"

	"github.com/codecrafter404/bubble/graph/model"
	"github.com/codecrafter404/bubble/utils"
)

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, order model.NewOrder) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: CreateOrder - createOrder"))
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, order int, state model.OrderState) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: UpdateOrder - updateOrder"))
}

// DeleteOrder is the resolver for the deleteOrder field.
func (r *mutationResolver) DeleteOrder(ctx context.Context, order int) (int, error) {
	panic(fmt.Errorf("not implemented: DeleteOrder - deleteOrder"))
}

// UpdateItem is the resolver for the updateItem field.
func (r *mutationResolver) UpdateItem(ctx context.Context, id int, item model.UpdateItem) (*model.Item, error) {
	tx, txErr := r.Db.Begin()
	if txErr != nil {
		return nil, fmt.Errorf("Failed to begin transaction: %w", txErr)
	}

	if item.Available != nil {
		_, updateErr := tx.Exec("UPDATE item SET available = ? WHERE id = ?", item.Available, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update available: %w", updateErr)
		}
	}

	if item.Identifier != nil {
		_, updateErr := tx.Exec("UPDATE item SET identifier = ? WHERE id = ?", item.Identifier, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update identifier: %w", updateErr)
		}
	}

	if item.Image != nil {
		_, updateErr := tx.Exec("UPDATE item SET image = ? WHERE id = ?", item.Image, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update image: %w", updateErr)
		}
	}

	if item.IsOneOff != nil {
		_, updateErr := tx.Exec("UPDATE item SET oneoff = ? WHERE id = ?", item.IsOneOff, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update IsOneOff: %w", updateErr)
		}
	}

	if item.Name != nil {
		_, updateErr := tx.Exec("UPDATE item SET name = ? WHERE id = ?", item.Name, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update name: %w", updateErr)
		}
	}

	if item.Price != nil {
		_, updateErr := tx.Exec("UPDATE item SET price = ? WHERE id = ?", item.Price, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update price: %w", updateErr)
		}
	}

	rows := tx.QueryRow("SELECT id, name, price, image, available, identifier, oneoff FROM item WHERE id = ?", id)
	var dest model.Item
	rows.Scan(&dest.ID, &dest.Name, &dest.Price, &dest.Image, &dest.Available, &dest.Identifier, &dest.IsOneOff)
	return &dest, nil
}

// UpdateCustomItem is the resolver for the updateCustomItem field.
func (r *mutationResolver) UpdateCustomItem(ctx context.Context, id int, item model.UpdateCustomItem) (*model.CustomItem, error) {
	tx, txErr := r.Db.Begin()
	if txErr != nil {
		return nil, fmt.Errorf("Failed to begin transaction: %w", txErr)
	}

	if item.Exclusive != nil {
		_, updateErr := tx.Exec("UPDATE custom_item SET exclusive = ? WHERE id = ?", item.Exclusive, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update exclusive: %w", updateErr)
		}
	}

	if item.Name != nil {
		_, updateErr := tx.Exec("UPDATE custom_item SET name = ? WHERE id = ?", item.Name, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update name: %w", updateErr)
		}
	}

	if item.Variants != nil {
		_, updateErr := tx.Exec("UPDATE custom_item SET variants = ? WHERE id = ?", item.Variants, id)
		if updateErr != nil {
			return nil, fmt.Errorf("Failed to update variants: %w", updateErr)
		}
	}
	panic(fmt.Errorf("not implemented: UpdateCustomItem - updateCustomItem"))
}

// CreateItems is the resolver for the createItems field.
func (r *mutationResolver) CreateItems(ctx context.Context, items []*model.ItemInput) ([]int, error) {
	uniqueIds := []int{}
	for _, i := range items {
		for _, x := range uniqueIds {
			if x == i.ID {
				return []int{}, fmt.Errorf("Id %d isn't unique", x)
			}
		}
		uniqueIds = append(uniqueIds, i.ID)
	}

	tx, err := r.Db.Begin()
	if err != nil {
		return []int{}, fmt.Errorf("Failed to beginn transaction: %w", err)
	}

	itemIDs := []int{}

	_, delErr := tx.Exec("DELETE FROM item;")
	if delErr != nil {
		return []int{}, fmt.Errorf("Failed to clean up old items: %w", delErr)
	}

	for _, item := range items {
		_, err = tx.Exec("INSERT INTO item (id, name, price, image, available, identifier, oneoff) VALUES (?, ?, ?, ?, ?, ?, ?);", item.ID, item.ID, item.Name, item.Price, item.Image, item.Available, item.Identifier, item.IsOneOff)
		if err != nil {
			return []int{}, fmt.Errorf("Failed to tx.exec insert for %d: %w", item.ID, err)
		}
		itemIDs = append(itemIDs, item.ID)

	}

	err = tx.Commit()
	if err != nil {
		return []int{}, fmt.Errorf("Failed to commit transaction: %w", err)
	}

	r.EventChannelMux.RLock()

	msg := model.UpdateEventUpdateItem
	for _, c := range r.EventChannel {
		select {
		case c <- &msg:
			break
		default:
			log.Println("Failed to UpdateEventUpdateItem event to channel")
			break
		}
	}

	r.EventChannelMux.RUnlock()

	return itemIDs, nil
}

// CreateCustomItems is the resolver for the createCustomItems field.
func (r *mutationResolver) CreateCustomItems(ctx context.Context, items []*model.CustomItemInput) ([]int, error) {
	graphItems := []utils.GraphNode{}
	uniqueIds := []int{}
	for _, i := range items {
		graphItems = append(graphItems, utils.GraphNode{Id: i.ID, DependsOn: i.DependsOn})
		for _, x := range uniqueIds {
			if x == i.ID {
				return []int{}, fmt.Errorf("Id %d isn't unique", x)
			}
		}
		uniqueIds = append(uniqueIds, i.ID)
	}

	if !utils.CheckDependencyLoop(graphItems) {
		return []int{}, fmt.Errorf("The supplied items have circular/unfeasable dependencies")
	}

	itemIds := []int{}

	rows, err := r.Db.Query("SELECT id FROM item WHERE oneoff == 0")
	if err != nil {
		return []int{}, fmt.Errorf("Failed to query existing item ids for dependency check: %w", err)
	}

	for rows.Next() {
		var res int

		err = rows.Scan(&res)
		if err != nil {
			return []int{}, fmt.Errorf("Failed to scan result fow (dep check): %w", err)
		}
		itemIds = append(itemIds, res)
	}

	for _, i := range items {
		valid := false
		for _, v := range i.Variants {
			found := false
			for _, x := range itemIds {
				if v == x {
					found = true
				}
			}
			if found {
				valid = true
			} else {
				break
			}
		}

		if !valid {
			return []int{}, fmt.Errorf("customitem %d depends on variant which doesn't exist (yet) or is marked as oneoff", i.ID)
		}
	}

	tx, err := r.Db.Begin()
	if err != nil {
		return []int{}, fmt.Errorf("Failed to begin transaction: %w", err)
	}
	insertedIds := []int{}

	_, delErr := tx.Exec("DELETE FROM custom_item_item_link; DELETE FROM custom_item")
	if delErr != nil {
		return []int{}, fmt.Errorf("failed to cleanup item: %w", delErr)
	}

	for _, i := range items {

		_, inErr := tx.Exec("INSERT INTO custom_item(id, name, depends_on, exclusive) VALUES (?, ?, ?, ?)", i.ID, i.Name, i.DependsOn, i.Exclusive)
		if inErr != nil {
			return []int{}, fmt.Errorf("failed to insert customitem %d: %w", i.ID, delErr)
		}

		for _, v := range i.Variants {
			_, vErr := tx.Exec("INSERT INTO custom_item_item_link(custom_item_id, item_id) VALUES (?, ?)", i.ID, v)
			if vErr != nil {
				return []int{}, fmt.Errorf("failed to insert variant_link %d for %d: %w", v, i.ID, delErr)
			}
		}
		insertedIds = append(insertedIds, i.ID)

	}
	comErr := tx.Commit()
	if comErr != nil {
		return []int{}, fmt.Errorf("Failed to commit transaction: %w", comErr)
	}

	r.EventChannelMux.RLock()

	msg := model.UpdateEventUpdateCustomitem
	for _, c := range r.EventChannel {
		select {
		case c <- &msg:
			break
		default:
			log.Println("Failed to UpdateEventUpdateCustomitem event to channel")
			break
		}
	}

	r.EventChannelMux.RUnlock()

	return insertedIds, nil
}

// GetPermission is the resolver for the getPermission field.
func (r *queryResolver) GetPermission(ctx context.Context) (model.User, error) {
	//TODO: implement authentication
	return model.UserUser, nil
}

// GetOrder is the resolver for the getOrder field.
func (r *queryResolver) GetOrder(ctx context.Context, id int) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: GetOrder - getOrder"))
}

// GetItems is the resolver for the getItems field.
func (r *queryResolver) GetItems(ctx context.Context) ([]*model.Item, error) {
	rows, err := r.Db.Query("SELECT id, name, price, image, available, identifier, oneoff FROM item")
	if err != nil {
		return []*model.Item{}, fmt.Errorf("Failed to query db: %w", err)
	}
	res := []*model.Item{}
	for rows.Next() {
		var item model.Item
		err := rows.Scan(&item.ID, &item.Name, &item.Price, &item.Image, &item.Available, &item.Identifier, &item.IsOneOff)
		if err != nil {
			return []*model.Item{}, fmt.Errorf("Failed to scan rows: %w", err)
		}
		res = append(res, &item)
	}
	return res, nil
}

// GetCustomItems is the resolver for the getCustomItems field.
func (r *queryResolver) GetCustomItems(ctx context.Context) ([]*model.CustomItem, error) {
	panic(fmt.Errorf("not implemented: GetCustomItems - getCustomItems"))
}

// Orders is the resolver for the orders field.
func (r *subscriptionResolver) Orders(ctx context.Context, state *model.OrderState, id *int, limit *int, skip *int) (<-chan []*model.Order, error) {
	panic(fmt.Errorf("not implemented: Orders - orders"))
}

// NextOrder is the resolver for the nextOrder field.
func (r *subscriptionResolver) NextOrder(ctx context.Context) (<-chan *model.Order, error) {
	panic(fmt.Errorf("not implemented: NextOrder - nextOrder"))
}

// Updates is the resolver for the updates field.
func (r *subscriptionResolver) Updates(ctx context.Context) (<-chan *model.UpdateEvent, error) {
	channel := make(chan *model.UpdateEvent)

	r.EventChannelMux.Lock()

	r.EventChannel = append(r.EventChannel, channel)

	r.EventChannelMux.Unlock()

	resChannel := make(chan *model.UpdateEvent)
	go func() {
		for res := range channel {
			select {
			case <-ctx.Done():
				r.EventChannelMux.Lock()
				res := []chan *model.UpdateEvent{}
				for _, c := range r.EventChannel {
					if c != channel {
						res = append(res, c)
					}
				}
				r.EventChannel = res
				r.EventChannelMux.Unlock()
				close(channel)
				close(resChannel)
				return
			default:
				resChannel <- res
			}
		}
	}()

	return resChannel, nil
}

// Stats is the resolver for the stats field.
func (r *subscriptionResolver) Stats(ctx context.Context) (<-chan *model.Statistics, error) {
	panic(fmt.Errorf("not implemented: Stats - stats"))
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
